{"version":3,"sources":["constants.js","context.js","MIDIFile.js","MusicScore.js","components/MusicPlayer/MusicPlayer.js","components/MusicPlayer/index.js","serviceWorker.js","index.js","utils/ScriptCache.js"],"names":["SCRIPTS","verovio","Score","React","createContext","MusicPlayer","ScoreProvider","Provider","ScoreConsumer","Consumer","MusicPlayerProvider","MusicPlayerConsumer","UTF8","isNotUTF8","bytes","byteOffset","byteLength","getStringFromBytes","e","getCharLength","theByte","getCharCode","charLength","charCode","mask","length","Error","concat","toString","slice","parseInt","strict","chars","push","String","fromCodePoint","join","getBytesForCharCode","setBytesFromCharCode","neededBytes","setBytesFromString","string","Infinity","i","j","codePointAt","MIDIEvents","MIDIFileHeader","buffer","a","ArrayBuffer","this","datas","DataView","HEADER_LENGTH","fromCharCode","getUint8","getUint32","Uint8Array","MIDIFileTrack","start","trackLength","HDR_LENGTH","getTrackLength","MIDIFile","strictMode","track","curIndex","buf","ensureArrayBuffer","header","tracks","getTracksCount","EVENT_META","EVENT_SYSEX","EVENT_DIVSYSEX","EVENT_MIDI","EVENT_META_SEQUENCE_NUMBER","EVENT_META_TEXT","EVENT_META_COPYRIGHT_NOTICE","EVENT_META_TRACK_NAME","EVENT_META_INSTRUMENT_NAME","EVENT_META_LYRICS","EVENT_META_MARKER","EVENT_META_CUE_POINT","EVENT_META_MIDI_CHANNEL_PREFIX","EVENT_META_END_OF_TRACK","EVENT_META_SET_TEMPO","EVENT_META_SMTPE_OFFSET","EVENT_META_TIME_SIGNATURE","EVENT_META_KEY_SIGNATURE","EVENT_META_SEQUENCER_SPECIFIC","EVENT_MIDI_NOTE_OFF","EVENT_MIDI_NOTE_ON","EVENT_MIDI_NOTE_AFTERTOUCH","EVENT_MIDI_CONTROLLER","EVENT_MIDI_PROGRAM_CHANGE","EVENT_MIDI_CHANNEL_AFTERTOUCH","EVENT_MIDI_PITCH_BEND","MIDI_1PARAM_EVENTS","MIDI_2PARAMS_EVENTS","createParser","stream","startAt","eventTypeByte","event","MIDIEventType","MIDIEventChannel","MIDIEventParam1","position","readUint8","readUint16","v","getUint16","readUint32","readVarInt","b","readBytes","pos","end","next","index","delta","type","data","badsubtype","subtype","msb","lsb","prefix","tempo","tempoBPM","hour","minutes","seconds","frames","subframes","key","scale","param1","param2","param3","param4","channel","writeToTrack","events","destination","k","l","indexOf","getRequiredBufferLength","bufferLength","FRAMES_PER_SECONDS","TICKS_PER_BEAT","prototype","getFormat","format","setFormat","setUint16","setTracksCount","n","getTickResolution","getSMPTEFrames","getTicksPerFrame","getTicksPerBeat","getTimeDivision","divisionWord","setTicksPerBeat","ticksPerBeat","smpteFrames","setSMTPEDivision","ticksPerFrame","setUint8","setTrackLength","setUint32","getTrackContent","setTrackContent","dataView","origin","startNote","song","takeTrack","notes","when","playTime","pitch","duration","slides","closeNote","addSlide","startDrum","takeBeat","volume","program","beats","beat","parseSong","getMidiEvents","console","log","getEvents","trackParsers","smallestDelta","filteredEvents","tickResolution","parser","curEvent","getLyrics","texts","lyrics","apply","Object","toConsumableArray","forEach","text","map","c","getTrackEvents","setTrackEvents","deleteTrack","splice","addTrack","getContent","m","Header","Track","WrappedComponent","base64ToArrayBuffer","base64","binaryString","window","atob","len","charCodeAt","findFirstIns","player","nn","loader","instrumentKeys","substring","state","currentSongTime","reverberator","isPlayed","leftTime","nextPositionTime","nextStepTime","playMode","playing","progress","songStart","audioContextFunc","AudioContext","webkitAudioContext","audioContext","_this","midiFile","midiSoundsRef","createRef","scrubberRef","stepDuration","handleAdjustPlay","bind","assertThisInitialized","startPlay","_this$state","cancelQueue","setState","prevState","currentTime","tick","handleAdjustVolume","_this$state2","sendNotes","Math","round","requestAnimationFrame","_this$state3","t","instr","info","variable","queueWaveTable","seek","_this$state4","scrubberRect","getBoundingClientRect","percent","clientX","left","width","parseMIDISong","midi","props","arrayBuffer","startLoad","current","_this$state5","createReverberator","output","connect","input","instrumentInfo","id","url","prevProps","_this$state6","_this$props","updateScore","vrvToolkit","vrvTime","max","vrvEle","getElementsAtTime","page","_this2","react_default","createElement","value","Box","direction","align","justify","MusicPlayer_PlayButton","onClick","flex","ref","MusicPlayer_AudioProgressBar","MusicPlayer_VolumeButton","midisoundsreact_default","appElementName","Component","PlayButton","_ref","_ref2","Button","hoverIndicator","icon","Pause","Play","VolumeButton","_ref3","icons","VolumeMute","VolumeLow","Volume","_ref4","AudioProgressBar","_ref5","_ref6","Meter","aria-label","size","thickness","values","color","ScoreStatusBar","MusicScore_Measure","MusicScore_ScoreViewOptions","Measure","totalPages","currentPage","Text","ScoreViewOptions","visibleOptions","gap","keys","option","CheckBox","label","Wrapper","isLoaded","error","musicScoreSvg","background","animation","margin","dangerouslySetInnerHTML","__html","alignContent","height","Music","_Component","ScoreWrapper","_getPrototypeOf2","classCallCheck","_len","arguments","args","Array","_key","possibleConstructorReturn","getPrototypeOf","call","errorMessage","musicScore","scriptCache","note","measure","updateScoreFollowingMIDI","handleKeyPress","arrowKeys","ArrowLeft","movePrevPage","ArrowRight","moveNextPage","ArrowUp","ArrowDown","default","inherits","createClass","fetchScoreData","initVrvToolkit","document","addEventListener","reloadScoreSVG","removeEventListener","options","pageHeight","zoom","pageWidth","adjustPageHeight","setOptions","pageNum","undefined","setScoreOption","redoLayout","renderToSVG","getPageCount","renderToMIDI","axios","method","responseType","then","response","catch","_this3","onLoad","err","tag","toolkit","loadScore","loadData","initScorePage","notesArr","goToPage","MusicScore_ScoreStatusBar","components_MusicPlayer","cache","Boolean","location","hostname","match","THEMES","grommet","hpe","dark","App","scoreEL","pageEl","scoreView","onScoreSizeChange","element","result","objectSpread","Grommet","theme","Grid","areas","name","columns","rows","gridArea","pad","between","Heading","level","responsive","textAlign","MusicScore","Paragraph","ReactDOM","render","src_App","getElementById","navigator","serviceWorker","ready","registration","unregister","global","counter","scriptMap","Map","ScriptCache","scripts","Cache","cb","stored","get","promise","scriptTag","src","has","initialState","loaded","Promise","resolve","reject","body","getElementsByTagName","crossorigin","async","cbName","Date","now","handleResult","evt","resolved","errored","onload","onerror","onreadystatechange","readyState","replace","appendChild","set","script"],"mappings":"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","file":"static/js/main.b370c83c.chunk.js","sourcesContent":["export const SCRIPTS = {\n  verovio: \"https://www.verovio.org/javascript/develop/verovio-toolkit.js\",\n};\n\nexport default {\n  SCRIPTS,\n};\n","import React from \"react\";\n\nconst Score = React.createContext({});\nconst MusicPlayer = React.createContext({});\n\nexport const ScoreProvider = Score.Provider;\nexport const ScoreConsumer = Score.Consumer;\n\nexport const MusicPlayerProvider = MusicPlayer.Provider;\nexport const MusicPlayerConsumer = MusicPlayer.Consumer;\n","/* eslint-disable */\n// forked https://github.com/surikov/webaudiofont/blob/master/examples/MIDIFile.js\n\nconst UTF8 = {\n  // non UTF8 encoding detection (cf README file for details)\n  isNotUTF8(bytes, byteOffset, byteLength) {\n    try {\n      UTF8.getStringFromBytes(bytes, byteOffset, byteLength, true);\n    } catch (e) {\n      return true;\n    }\n    return false;\n  },\n  // UTF8 decoding functions\n  getCharLength(theByte) {\n    // 4 bytes encoded char (mask 11110000)\n    if ((theByte & 0xf0) === 0xf0) {\n      return 4;\n      // 3 bytes encoded char (mask 11100000)\n    }\n    if ((theByte & 0xe0) === 0xe0) {\n      return 3;\n      // 2 bytes encoded char (mask 11000000)\n    }\n    if ((theByte & 0xc0) === 0xc0) {\n      return 2;\n      // 1 bytes encoded char\n    }\n    if (theByte === (theByte & 0x7f)) {\n      return 1;\n    }\n    return 0;\n  },\n  getCharCode(bytes, byteOffset, charLength) {\n    let charCode = 0;\n    let mask = \"\";\n    byteOffset = byteOffset || 0;\n    // validate that the array has at least one byte in it\n    if (bytes.length - byteOffset <= 0) {\n      throw new Error(\"No more characters remaining in array.\");\n    }\n    // Retrieve charLength if not given\n    charLength = charLength || UTF8.getCharLength(bytes[byteOffset]);\n    if (charLength === 0) {\n      throw new Error(\n        `${bytes[byteOffset].toString(2)} is not a significative` +\n          ` byte (offset:${byteOffset}).`\n      );\n    }\n    // Return byte value if charlength is 1\n    if (charLength === 1) {\n      return bytes[byteOffset];\n    }\n    // validate that the array has enough bytes to make up this character\n    if (bytes.length - byteOffset < charLength) {\n      throw new Error(\n        `Expected at least ${charLength} bytes remaining in array.`\n      );\n    }\n    // Test UTF8 integrity\n    mask =\n      \"00000000\".slice(0, charLength) + 1 + \"00000000\".slice(charLength + 1);\n    if (bytes[byteOffset] & parseInt(mask, 2)) {\n      throw Error(\n        `Index ${byteOffset}: A ${charLength} bytes` +\n          ` encoded char` +\n          ` cannot encode the ${charLength + 1}th rank bit to 1.`\n      );\n    }\n    // Reading the first byte\n    mask = \"0000\".slice(0, charLength + 1) + \"11111111\".slice(charLength + 1);\n    charCode += (bytes[byteOffset] & parseInt(mask, 2)) << (--charLength * 6);\n    // Reading the next bytes\n    while (charLength) {\n      if (\n        (bytes[byteOffset + 1] & 0x80) !== 0x80 ||\n        (bytes[byteOffset + 1] & 0x40) === 0x40\n      ) {\n        throw Error(\n          `Index ${byteOffset + 1}: Next bytes of encoded char` +\n            ` must begin with a \"10\" bit sequence.`\n        );\n      }\n      charCode += (bytes[++byteOffset] & 0x3f) << (--charLength * 6);\n    }\n    return charCode;\n  },\n  getStringFromBytes(bytes, byteOffset, byteLength, strict) {\n    let charLength;\n    const chars = [];\n    byteOffset |= 0;\n    byteLength =\n      typeof byteLength === \"number\"\n        ? byteLength\n        : bytes.byteLength || bytes.length;\n    for (; byteOffset < byteLength; byteOffset++) {\n      charLength = UTF8.getCharLength(bytes[byteOffset]);\n      if (byteOffset + charLength > byteLength) {\n        if (strict) {\n          throw Error(\n            `Index ${byteOffset}: Found a ${charLength} bytes encoded \n            char declaration but only ${byteLength -\n              byteOffset} bytes are available.`\n          );\n        }\n      } else {\n        chars.push(\n          String.fromCodePoint(\n            UTF8.getCharCode(bytes, byteOffset, charLength, strict)\n          )\n        );\n      }\n      byteOffset += charLength - 1;\n    }\n    return chars.join(\"\");\n  },\n  // UTF8 encoding functions\n  getBytesForCharCode(charCode) {\n    if (charCode < 128) {\n      return 1;\n    }\n    if (charCode < 2048) {\n      return 2;\n    }\n    if (charCode < 65536) {\n      return 3;\n    }\n    if (charCode < 2097152) {\n      return 4;\n    }\n    throw new Error(`CharCode ${charCode} cannot be encoded with UTF8.`);\n  },\n  setBytesFromCharCode(charCode, bytes, byteOffset, neededBytes) {\n    charCode |= 0;\n    bytes = bytes || [];\n    byteOffset |= 0;\n    neededBytes = neededBytes || UTF8.getBytesForCharCode(charCode);\n    // Setting the charCode as it to bytes if the byte length is 1\n    if (neededBytes === 1) {\n      bytes[byteOffset] = charCode;\n    } else {\n      // Computing the first byte\n      bytes[byteOffset++] =\n        (parseInt(\"1111\".slice(0, neededBytes), 2) << (8 - neededBytes)) +\n        (charCode >>> (--neededBytes * 6));\n      // Computing next bytes\n      for (; neededBytes > 0; ) {\n        bytes[byteOffset++] =\n          ((charCode >>> (--neededBytes * 6)) & 0x3f) | 0x80;\n      }\n    }\n    return bytes;\n  },\n  setBytesFromString(string, bytes, byteOffset, byteLength, strict) {\n    string = string || \"\";\n    bytes = bytes || [];\n    byteOffset |= 0;\n    byteLength =\n      typeof byteLength === \"number\"\n        ? byteLength\n        : bytes.byteLength || Infinity;\n    for (let i = 0, j = string.length; i < j; i++) {\n      const neededBytes = UTF8.getBytesForCharCode(string[i].codePointAt(0));\n      if (strict && byteOffset + neededBytes > byteLength) {\n        throw new Error(\n          `Not enought bytes to encode the char \"${\n            string[i]\n          }\" at the offset \"${byteOffset}\".`\n        );\n      }\n      UTF8.setBytesFromCharCode(\n        string[i].codePointAt(0),\n        bytes,\n        byteOffset,\n        neededBytes,\n        strict\n      );\n      byteOffset += neededBytes;\n    }\n    return bytes;\n  },\n};\n\n// ..................................................................\n\n// MIDIEvents : Read and edit events from various sources (ArrayBuffer, Stream)\nfunction MIDIEvents() {\n  throw new Error(\"MIDIEvents function not intended to be run.\");\n}\n\n// Static constants\n// Event types\nMIDIEvents.EVENT_META = 0xff;\nMIDIEvents.EVENT_SYSEX = 0xf0;\nMIDIEvents.EVENT_DIVSYSEX = 0xf7;\nMIDIEvents.EVENT_MIDI = 0x8;\n// Meta event types\nMIDIEvents.EVENT_META_SEQUENCE_NUMBER = 0x00;\nMIDIEvents.EVENT_META_TEXT = 0x01;\nMIDIEvents.EVENT_META_COPYRIGHT_NOTICE = 0x02;\nMIDIEvents.EVENT_META_TRACK_NAME = 0x03;\nMIDIEvents.EVENT_META_INSTRUMENT_NAME = 0x04;\nMIDIEvents.EVENT_META_LYRICS = 0x05;\nMIDIEvents.EVENT_META_MARKER = 0x06;\nMIDIEvents.EVENT_META_CUE_POINT = 0x07;\nMIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX = 0x20;\nMIDIEvents.EVENT_META_END_OF_TRACK = 0x2f;\nMIDIEvents.EVENT_META_SET_TEMPO = 0x51;\nMIDIEvents.EVENT_META_SMTPE_OFFSET = 0x54;\nMIDIEvents.EVENT_META_TIME_SIGNATURE = 0x58;\nMIDIEvents.EVENT_META_KEY_SIGNATURE = 0x59;\nMIDIEvents.EVENT_META_SEQUENCER_SPECIFIC = 0x7f;\n// MIDI event types\nMIDIEvents.EVENT_MIDI_NOTE_OFF = 0x8;\nMIDIEvents.EVENT_MIDI_NOTE_ON = 0x9;\nMIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH = 0xa;\nMIDIEvents.EVENT_MIDI_CONTROLLER = 0xb;\nMIDIEvents.EVENT_MIDI_PROGRAM_CHANGE = 0xc;\nMIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH = 0xd;\nMIDIEvents.EVENT_MIDI_PITCH_BEND = 0xe;\n// MIDI event sizes\nMIDIEvents.MIDI_1PARAM_EVENTS = [\n  MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE,\n  MIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH,\n];\nMIDIEvents.MIDI_2PARAMS_EVENTS = [\n  MIDIEvents.EVENT_MIDI_NOTE_OFF,\n  MIDIEvents.EVENT_MIDI_NOTE_ON,\n  MIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH,\n  MIDIEvents.EVENT_MIDI_CONTROLLER,\n  MIDIEvents.EVENT_MIDI_PITCH_BEND,\n];\n\n// Create an event stream parser\nMIDIEvents.createParser = function midiEventsCreateParser(\n  stream,\n  startAt,\n  strictMode\n) {\n  // Private vars\n  // Common vars\n  let eventTypeByte;\n  let event;\n  // MIDI events vars\n  let MIDIEventType;\n  let MIDIEventChannel;\n  let MIDIEventParam1;\n\n  // Wrap DataView into a data stream\n  if (stream instanceof DataView) {\n    stream = {\n      position: startAt || 0,\n      buffer: stream,\n      readUint8() {\n        return this.buffer.getUint8(this.position++);\n      },\n      readUint16() {\n        const v = this.buffer.getUint16(this.position);\n        this.position = this.position + 2;\n        return v;\n      },\n      readUint32() {\n        const v = this.buffer.getUint16(this.position);\n        this.position = this.position + 2;\n        return v;\n      },\n      readVarInt() {\n        let v = 0;\n        let i = 0;\n        let b;\n        while (i++ < 4) {\n          b = this.readUint8();\n\n          if (b & 0x80) {\n            v += b & 0x7f;\n            v <<= 7;\n          } else {\n            return v + b;\n          }\n        }\n        throw new Error(\n          `0x${this.position.toString(16)}:` +\n            ` Variable integer length cannot exceed 4 bytes`\n        );\n      },\n      readBytes(length) {\n        const bytes = [];\n\n        for (; length > 0; length--) {\n          bytes.push(this.readUint8());\n        }\n        return bytes;\n      },\n      pos() {\n        return `0x${(this.buffer.byteOffset + this.position).toString(16)}`;\n      },\n      end() {\n        return this.position === this.buffer.byteLength;\n      },\n    };\n    startAt = 0;\n  }\n  // Consume stream till not at start index\n  if (startAt > 0) {\n    while (startAt--) {\n      stream.readUint8();\n    }\n  }\n  // creating the parser object\n  return {\n    // Read the next event\n    next() {\n      // Check available datas\n      if (stream.end()) {\n        return null;\n      }\n      // Creating the event\n      event = {\n        // Memoize the event index\n        index: stream.pos(),\n        // Read the delta time\n        delta: stream.readVarInt(),\n      };\n      // Read the eventTypeByte\n      eventTypeByte = stream.readUint8();\n      if ((eventTypeByte & 0xf0) === 0xf0) {\n        // Meta events\n        if (eventTypeByte === MIDIEvents.EVENT_META) {\n          event.type = MIDIEvents.EVENT_META;\n          event.subtype = stream.readUint8();\n          event.length = stream.readVarInt();\n          switch (event.subtype) {\n            case MIDIEvents.EVENT_META_SEQUENCE_NUMBER:\n              if (strictMode && event.length !== 2) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.msb = stream.readUint8();\n              event.lsb = stream.readUint8();\n              return event;\n            case MIDIEvents.EVENT_META_TEXT:\n            case MIDIEvents.EVENT_META_COPYRIGHT_NOTICE:\n            case MIDIEvents.EVENT_META_TRACK_NAME:\n            case MIDIEvents.EVENT_META_INSTRUMENT_NAME:\n            case MIDIEvents.EVENT_META_LYRICS:\n            case MIDIEvents.EVENT_META_MARKER:\n            case MIDIEvents.EVENT_META_CUE_POINT:\n              event.data = stream.readBytes(event.length);\n              return event;\n            case MIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX:\n              if (strictMode && event.length !== 1) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.prefix = stream.readUint8();\n              return event;\n            case MIDIEvents.EVENT_META_END_OF_TRACK:\n              if (strictMode && event.length !== 0) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              return event;\n            case MIDIEvents.EVENT_META_SET_TEMPO:\n              if (strictMode && event.length !== 3) {\n                throw new Error(\n                  `${stream.pos()} Tempo meta event length must be 3.`\n                );\n              }\n              event.tempo =\n                (stream.readUint8() << 16) +\n                (stream.readUint8() << 8) +\n                stream.readUint8();\n              event.tempoBPM = 60000000 / event.tempo;\n              return event;\n            case MIDIEvents.EVENT_META_SMTPE_OFFSET:\n              if (strictMode && event.length !== 5) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.hour = stream.readUint8();\n              if (strictMode && event.hour > 23) {\n                throw new Error(\n                  `${stream.pos()} SMTPE offset hour value must` +\n                    ` be part of 0-23.`\n                );\n              }\n              event.minutes = stream.readUint8();\n              if (strictMode && event.minutes > 59) {\n                throw new Error(\n                  `${stream.pos()} SMTPE offset minutes value` +\n                    ` must be part of 0-59.`\n                );\n              }\n              event.seconds = stream.readUint8();\n              if (strictMode && event.seconds > 59) {\n                throw new Error(\n                  `${stream.pos()} SMTPE offset seconds value` +\n                    ` must be part of 0-59.`\n                );\n              }\n              event.frames = stream.readUint8();\n              if (strictMode && event.frames > 30) {\n                throw new Error(\n                  `${stream.pos()} SMTPE offset frames value must` +\n                    ` be part of 0-30.`\n                );\n              }\n              event.subframes = stream.readUint8();\n              if (strictMode && event.subframes > 99) {\n                throw new Error(\n                  `${stream.pos()} SMTPE offset subframes value` +\n                    ` must be part of 0-99.`\n                );\n              }\n              return event;\n            case MIDIEvents.EVENT_META_KEY_SIGNATURE:\n              if (strictMode && event.length !== 2) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.key = stream.readUint8();\n              if (strictMode && (event.key < -7 || event.key > 7)) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.scale = stream.readUint8();\n              if (strictMode && event.scale !== 0 && event.scale !== 1) {\n                throw new Error(\n                  `${stream.pos()} Key signature scale value must` +\n                    ` be 0 or 1.`\n                );\n              }\n              return event;\n            case MIDIEvents.EVENT_META_TIME_SIGNATURE:\n              if (strictMode && event.length !== 4) {\n                throw new Error(`${stream.pos()} Bad metaevent length.`);\n              }\n              event.data = stream.readBytes(event.length);\n              event.param1 = event.data[0];\n              event.param2 = event.data[1];\n              event.param3 = event.data[2];\n              event.param4 = event.data[3];\n              return event;\n            case MIDIEvents.EVENT_META_SEQUENCER_SPECIFIC:\n              event.data = stream.readBytes(event.length);\n              return event;\n            default:\n              if (strictMode) {\n                throw new Error(\n                  `${stream.pos()} Unknown meta event type ` +\n                    `(${event.subtype.toString(16)}).`\n                );\n              }\n              event.data = stream.readBytes(event.length);\n              return event;\n          }\n          // System events\n        } else if (\n          eventTypeByte === MIDIEvents.EVENT_SYSEX ||\n          eventTypeByte === MIDIEvents.EVENT_DIVSYSEX\n        ) {\n          event.type = eventTypeByte;\n          event.length = stream.readVarInt();\n          event.data = stream.readBytes(event.length);\n          return event;\n          // Unknown event, assuming it\"s system like event\n        } else {\n          if (strictMode) {\n            throw new Error(\n              `${stream.pos()} Unknown event type ${eventTypeByte.toString(\n                16\n              )}, Delta: ${event.delta}.`\n            );\n          }\n          event.type = eventTypeByte;\n          event.badsubtype = stream.readVarInt();\n          event.length = stream.readUint8();\n          event.data = stream.readBytes(event.length);\n          return event;\n        }\n        // MIDI eventsdestination[index++]\n      } else {\n        // running status\n        if ((eventTypeByte & 0x80) === 0) {\n          if (!MIDIEventType) {\n            throw new Error(\n              `${stream.pos()} Running status without previous event`\n            );\n          }\n          MIDIEventParam1 = eventTypeByte;\n        } else {\n          MIDIEventType = eventTypeByte >> 4;\n          MIDIEventChannel = eventTypeByte & 0x0f;\n          MIDIEventParam1 = stream.readUint8();\n        }\n        event.type = MIDIEvents.EVENT_MIDI;\n        event.subtype = MIDIEventType;\n        event.channel = MIDIEventChannel;\n        event.param1 = MIDIEventParam1;\n        switch (MIDIEventType) {\n          case MIDIEvents.EVENT_MIDI_NOTE_OFF:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_NOTE_ON:\n            event.param2 = stream.readUint8();\n\n            // If velocity is 0, it\"s a note off event in fact\n            if (!event.param2) {\n              event.subtype = MIDIEvents.EVENT_MIDI_NOTE_OFF;\n              event.param2 = 127; // Find a standard telling what to do here\n            }\n            return event;\n          case MIDIEvents.EVENT_MIDI_NOTE_AFTERTOUCH:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_CONTROLLER:\n            event.param2 = stream.readUint8();\n            return event;\n          case MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE:\n            return event;\n          case MIDIEvents.EVENT_MIDI_CHANNEL_AFTERTOUCH:\n            return event;\n          case MIDIEvents.EVENT_MIDI_PITCH_BEND:\n            event.param2 = stream.readUint8();\n            return event;\n          default:\n            if (strictMode) {\n              throw new Error(\n                `${stream.pos()} Unknown MIDI event type ` +\n                  `(${MIDIEventType.toString(16)}).`\n              );\n            }\n            return event;\n        }\n      }\n    },\n  };\n};\n\n// Return the buffer length needed to encode the given events\nMIDIEvents.writeToTrack = function midiEventsWriteToTrack(\n  events,\n  destination,\n  strictMode\n) {\n  let index = 0;\n  let i;\n  let j;\n  let k;\n  let l;\n\n  // Converting each event to binary MIDI datas\n  for (i = 0, j = events.length; i < j; i++) {\n    // Writing delta value\n    if (events[i].delta >>> 28) {\n      throw Error(\n        `Event #${i}: Maximum delta time value reached (${\n          events[i].delta\n        }/134217728 max)`\n      );\n    }\n    if (events[i].delta >>> 21) {\n      destination[index++] = ((events[i].delta >>> 21) & 0x7f) | 0x80;\n    }\n    if (events[i].delta >>> 14) {\n      destination[index++] = ((events[i].delta >>> 14) & 0x7f) | 0x80;\n    }\n    if (events[i].delta >>> 7) {\n      destination[index++] = ((events[i].delta >>> 7) & 0x7f) | 0x80;\n    }\n    destination[index++] = events[i].delta & 0x7f;\n    // MIDI Events encoding\n    if (events[i].type === MIDIEvents.EVENT_MIDI) {\n      // Adding the byte of subtype + channel\n      destination[index++] = (events[i].subtype << 4) + events[i].channel;\n      // Adding the byte of the first params\n      destination[index++] = events[i].param1;\n      // Adding a byte for the optionnal second param\n      if (MIDIEvents.MIDI_2PARAMS_EVENTS.indexOf(events[i].subtype) !== -1) {\n        destination[index++] = events[i].param2;\n      }\n      // META / SYSEX events encoding\n    } else {\n      // Adding the event type byte\n      destination[index++] = events[i].type;\n      // Adding the META event subtype byte\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        destination[index++] = events[i].subtype;\n      }\n      // Writing the event length bytes\n      if (events[i].length >>> 28) {\n        throw Error(\n          `Event #${i}: Maximum length reached (${\n            events[i].length\n          }/134217728 max)`\n        );\n      }\n      if (events[i].length >>> 21) {\n        destination[index++] = ((events[i].length >>> 21) & 0x7f) | 0x80;\n      }\n      if (events[i].length >>> 14) {\n        destination[index++] = ((events[i].length >>> 14) & 0x7f) | 0x80;\n      }\n      if (events[i].length >>> 7) {\n        destination[index++] = ((events[i].length >>> 7) & 0x7f) | 0x80;\n      }\n      destination[index++] = events[i].length & 0x7f;\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        switch (events[i].subtype) {\n          case MIDIEvents.EVENT_META_SEQUENCE_NUMBER:\n            destination[index++] = events[i].msb;\n            destination[index++] = events[i].lsb;\n            break;\n          case MIDIEvents.EVENT_META_TEXT:\n          case MIDIEvents.EVENT_META_COPYRIGHT_NOTICE:\n          case MIDIEvents.EVENT_META_TRACK_NAME:\n          case MIDIEvents.EVENT_META_INSTRUMENT_NAME:\n          case MIDIEvents.EVENT_META_LYRICS:\n          case MIDIEvents.EVENT_META_MARKER:\n          case MIDIEvents.EVENT_META_CUE_POINT:\n            for (k = 0, l = events[i].length; k < l; k++) {\n              destination[index++] = events[i].data[k];\n            }\n            break;\n          case MIDIEvents.EVENT_META_MIDI_CHANNEL_PREFIX:\n            destination[index++] = events[i].prefix;\n            break;\n          case MIDIEvents.EVENT_META_END_OF_TRACK:\n            break;\n          case MIDIEvents.EVENT_META_SET_TEMPO:\n            destination[index++] = events[i].tempo >> 16;\n            destination[index++] = (events[i].tempo >> 8) & 0xff;\n            destination[index++] = events[i].tempo & 0xff;\n            break;\n          case MIDIEvents.EVENT_META_SMTPE_OFFSET:\n            if (strictMode && events[i].hour > 23) {\n              throw new Error(\n                `Event #${i}: SMTPE offset hour value must be` +\n                  ` part of 0-23.`\n              );\n            }\n            destination[index++] = events[i].hour;\n            if (strictMode && events[i].minutes > 59) {\n              throw new Error(\n                `Event #${i}: SMTPE offset minutes value must` +\n                  ` be part of 0-59.`\n              );\n            }\n            destination[index++] = events[i].minutes;\n            if (strictMode && events[i].seconds > 59) {\n              throw new Error(\n                `Event #${i}: SMTPE offset seconds value must` +\n                  ` be part of 0-59.`\n              );\n            }\n            destination[index++] = events[i].seconds;\n            if (strictMode && events[i].frames > 30) {\n              throw new Error(\n                `Event #${i}: SMTPE offset frames amount must` +\n                  ` be part of 0-30.`\n              );\n            }\n            destination[index++] = events[i].frames;\n            if (strictMode && events[i].subframes > 99) {\n              throw new Error(\n                `Event #${i}: SMTPE offset subframes amount` +\n                  ` must be part of 0-99.`\n              );\n            }\n            destination[index++] = events[i].subframes;\n            break;\n          case MIDIEvents.EVENT_META_KEY_SIGNATURE:\n            if (\n              typeof events[i].key !== \"number\" ||\n              events[i].key < -7 ||\n              events[i].scale > 7\n            ) {\n              throw new Error(\n                `Event #${i}:The key signature key must be` +\n                  ` between -7 and 7`\n              );\n            }\n            if (\n              typeof events[i].scale !== \"number\" ||\n              events[i].scale < 0 ||\n              events[i].scale > 1\n            ) {\n              throw new Error(\n                `Event #${i}:` + `The key signature scale must be 0 or 1`\n              );\n            }\n            destination[index++] = events[i].key;\n            destination[index++] = events[i].scale;\n            break;\n          // Not implemented\n          case MIDIEvents.EVENT_META_TIME_SIGNATURE:\n          case MIDIEvents.EVENT_META_SEQUENCER_SPECIFIC:\n          default:\n            for (k = 0, l = events[i].length; k < l; k++) {\n              destination[index++] = events[i].data[k];\n            }\n            break;\n        }\n        // Adding bytes corresponding to the sysex event datas\n      } else {\n        for (k = 0, l = events[i].length; k < l; k++) {\n          destination[index++] = events[i].data[k];\n        }\n      }\n    }\n  }\n};\n\n// Return the buffer length needed to encode the given events\nMIDIEvents.getRequiredBufferLength = function(events) {\n  let bufferLength = 0;\n  let i = 0;\n  let j;\n\n  // Calculating the track size by adding events lengths\n  for (i = 0, j = events.length; i < j; i++) {\n    // Computing necessary bytes to encode the delta value\n    bufferLength +=\n      events[i].delta >>> 21\n        ? 4\n        : events[i].delta >>> 14\n        ? 3\n        : events[i].delta >>> 7\n        ? 2\n        : 1;\n    // MIDI Events have various fixed lengths\n    if (events[i].type === MIDIEvents.EVENT_MIDI) {\n      // Adding a byte for subtype + channel\n      bufferLength++;\n      // Adding a byte for the first params\n      bufferLength++;\n      // Adding a byte for the optionnal second param\n      if (MIDIEvents.MIDI_2PARAMS_EVENTS.indexOf(events[i].subtype) !== -1) {\n        bufferLength++;\n      }\n      // META / SYSEX events lengths are self defined\n    } else {\n      // Adding a byte for the event type\n      bufferLength++;\n      // Adding a byte for META events subtype\n      if (events[i].type === MIDIEvents.EVENT_META) {\n        bufferLength++;\n      }\n      // Adding necessary bytes to encode the length\n      bufferLength +=\n        events[i].length >>> 21\n          ? 4\n          : events[i].length >>> 14\n          ? 3\n          : events[i].length >>> 7\n          ? 2\n          : 1;\n      // Adding bytes corresponding to the event length\n      bufferLength += events[i].length;\n    }\n  }\n  return bufferLength;\n};\n\n// /...........................................\n\n// MIDIFileHeader : Read and edit a MIDI header chunk in a given ArrayBuffer\nfunction MIDIFileHeader(buffer) {\n  let a;\n  // No buffer creating him\n  if (!buffer) {\n    a = new Uint8Array(MIDIFileHeader.HEADER_LENGTH);\n    // Adding the header id (MThd)\n    a[0] = 0x4d;\n    a[1] = 0x54;\n    a[2] = 0x68;\n    a[3] = 0x64;\n    // Adding the header chunk size\n    a[4] = 0x00;\n    a[5] = 0x00;\n    a[6] = 0x00;\n    a[7] = 0x06;\n    // Adding the file format (1 here cause it\"s the most commonly used)\n    a[8] = 0x00;\n    a[9] = 0x01;\n    // Adding the track count (1 cause it\"s a new file)\n    a[10] = 0x00;\n    a[11] = 0x01;\n    // Adding the time division (192 ticks per beat)\n    a[12] = 0x00;\n    a[13] = 0xc0;\n    // saving the buffer\n    this.datas = new DataView(a.buffer, 0, MIDIFileHeader.HEADER_LENGTH);\n    // Parsing the given buffer\n  } else {\n    if (!(buffer instanceof ArrayBuffer)) {\n      throw Error(\"Invalid buffer received.\");\n    }\n    this.datas = new DataView(buffer, 0, MIDIFileHeader.HEADER_LENGTH);\n    // Reading MIDI header chunk\n    if (\n      !(\n        String.fromCharCode(this.datas.getUint8(0)) === \"M\" &&\n        String.fromCharCode(this.datas.getUint8(1)) === \"T\" &&\n        String.fromCharCode(this.datas.getUint8(2)) === \"h\" &&\n        String.fromCharCode(this.datas.getUint8(3)) === \"d\"\n      )\n    ) {\n      throw new Error(\"Invalid MIDIFileHeader : MThd prefix not found\");\n    }\n    // Reading chunk length\n    if (this.datas.getUint32(4) !== 6) {\n      throw new Error(\"Invalid MIDIFileHeader : Chunk length must be 6\");\n    }\n  }\n}\n\n// Static constants\nMIDIFileHeader.HEADER_LENGTH = 14;\nMIDIFileHeader.FRAMES_PER_SECONDS = 1;\nMIDIFileHeader.TICKS_PER_BEAT = 2;\n\n// MIDI file format\nMIDIFileHeader.prototype.getFormat = function() {\n  const format = this.datas.getUint16(8);\n  if (format !== 0 && format !== 1 && format !== 2) {\n    throw new Error(\n      `Invalid MIDI file : MIDI format (${format}),` +\n        ` format can be 0, 1 or 2 only.`\n    );\n  }\n  return format;\n};\n\nMIDIFileHeader.prototype.setFormat = function(format) {\n  if (format !== 0 && format !== 1 && format !== 2) {\n    throw new Error(\n      `Invalid MIDI format given (${format}),` +\n        ` format can be 0, 1 or 2 only.`\n    );\n  }\n  this.datas.setUint16(8, format);\n};\n\n// Number of tracks\nMIDIFileHeader.prototype.getTracksCount = function() {\n  return this.datas.getUint16(10);\n};\n\nMIDIFileHeader.prototype.setTracksCount = function(n) {\n  return this.datas.setUint16(10, n);\n};\n\n// Tick compute\nMIDIFileHeader.prototype.getTickResolution = function(tempo) {\n  // Frames per seconds\n  if (this.datas.getUint16(12) & 0x8000) {\n    return 1000000 / (this.getSMPTEFrames() * this.getTicksPerFrame());\n    // Ticks per beat\n  }\n  // Default MIDI tempo is 120bpm, 500ms per beat\n  tempo = tempo || 500000;\n  return tempo / this.getTicksPerBeat();\n};\n\n// Time division type\nMIDIFileHeader.prototype.getTimeDivision = function() {\n  if (this.datas.getUint16(12) & 0x8000) {\n    return MIDIFileHeader.FRAMES_PER_SECONDS;\n  }\n  return MIDIFileHeader.TICKS_PER_BEAT;\n};\n\n// Ticks per beat\nMIDIFileHeader.prototype.getTicksPerBeat = function() {\n  const divisionWord = this.datas.getUint16(12);\n  if (divisionWord & 0x8000) {\n    throw new Error(\"Time division is not expressed as ticks per beat.\");\n  }\n  return divisionWord;\n};\n\nMIDIFileHeader.prototype.setTicksPerBeat = function(ticksPerBeat) {\n  this.datas.setUint16(12, ticksPerBeat & 0x7fff);\n};\n\n// Frames per seconds\nMIDIFileHeader.prototype.getSMPTEFrames = function() {\n  const divisionWord = this.datas.getUint16(12);\n  let smpteFrames;\n\n  if (!(divisionWord & 0x8000)) {\n    throw new Error(\"Time division is not expressed as frames per seconds.\");\n  }\n  smpteFrames = divisionWord & 0x7f00;\n  if ([24, 25, 29, 30].indexOf(smpteFrames) === -1) {\n    throw new Error(`Invalid SMPTE frames value (${smpteFrames}).`);\n  }\n  return smpteFrames === 29 ? 29.97 : smpteFrames;\n};\n\nMIDIFileHeader.prototype.getTicksPerFrame = function() {\n  const divisionWord = this.datas.getUint16(12);\n\n  if (!(divisionWord & 0x8000)) {\n    throw new Error(\"Time division is not expressed as frames per seconds.\");\n  }\n  return divisionWord & 0x00ff;\n};\n\nMIDIFileHeader.prototype.setSMTPEDivision = function(\n  smpteFrames,\n  ticksPerFrame\n) {\n  if (smpteFrames === 29.97) {\n    smpteFrames = 29;\n  }\n  if ([24, 25, 29, 30].indexOf(smpteFrames) === -1) {\n    throw new Error(`Invalid SMPTE frames value given (${smpteFrames}).`);\n  }\n  if (ticksPerFrame < 0 || ticksPerFrame > 0xff) {\n    throw new Error(`Invalid ticks per frame value given (${smpteFrames}).`);\n  }\n  this.datas.setUint8(12, 0x80 | smpteFrames);\n  this.datas.setUint8(13, ticksPerFrame);\n};\n\n// /...........................................\n// MIDIFileTrack : Read and edit a MIDI track chunk in a given ArrayBuffer\nfunction MIDIFileTrack(buffer, start) {\n  let a;\n  let trackLength;\n\n  // no buffer, creating him\n  if (!buffer) {\n    a = new Uint8Array(12);\n    // Adding the empty track header (MTrk)\n    a[0] = 0x4d;\n    a[1] = 0x54;\n    a[2] = 0x72;\n    a[3] = 0x6b;\n    // Adding the empty track size (4)\n    a[4] = 0x00;\n    a[5] = 0x00;\n    a[6] = 0x00;\n    a[7] = 0x04;\n    // Adding the track end event\n    a[8] = 0x00;\n    a[9] = 0xff;\n    a[10] = 0x2f;\n    a[11] = 0x00;\n    // Saving the buffer\n    this.datas = new DataView(a.buffer, 0, MIDIFileTrack.HDR_LENGTH + 4);\n    // parsing the given buffer\n  } else {\n    if (!(buffer instanceof ArrayBuffer)) {\n      throw new Error(\"Invalid buffer received.\");\n    }\n    // Buffer length must size at least like an  empty track (8+3bytes)\n    if (buffer.byteLength - start < 12) {\n      throw new Error(\n        `Invalid MIDIFileTrack (0x${start.toString(16)}) :` +\n          ` Buffer length must size at least 12bytes`\n      );\n    }\n    // Creating a temporary view to read the track header\n    this.datas = new DataView(buffer, start, MIDIFileTrack.HDR_LENGTH);\n    // Reading MIDI track header chunk\n    if (\n      !(\n        String.fromCharCode(this.datas.getUint8(0)) === \"M\" &&\n        String.fromCharCode(this.datas.getUint8(1)) === \"T\" &&\n        String.fromCharCode(this.datas.getUint8(2)) === \"r\" &&\n        String.fromCharCode(this.datas.getUint8(3)) === \"k\"\n      )\n    ) {\n      throw new Error(\n        `Invalid MIDIFileTrack (0x${start.toString(16)}) :` +\n          ` MTrk prefix not found`\n      );\n    }\n    // Reading the track length\n    trackLength = this.getTrackLength();\n    if (buffer.byteLength - start < trackLength) {\n      throw new Error(\n        `Invalid MIDIFileTrack (0x${start.toString(16)}) :` +\n          ` The track size exceed the buffer length.`\n      );\n    }\n    // Creating the final DataView\n    this.datas = new DataView(\n      buffer,\n      start,\n      MIDIFileTrack.HDR_LENGTH + trackLength\n    );\n    // Trying to find the end of track event\n    if (\n      !(\n        this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 3)) ===\n          0xff &&\n        this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 2)) ===\n          0x2f &&\n        this.datas.getUint8(MIDIFileTrack.HDR_LENGTH + (trackLength - 1)) ===\n          0x00\n      )\n    ) {\n      throw new Error(\n        `Invalid MIDIFileTrack (0x${start.toString(16)}) :` +\n          ` No track end event found at the expected index` +\n          ` (${(MIDIFileTrack.HDR_LENGTH + (trackLength - 1)).toString(16)}).`\n      );\n    }\n  }\n}\n\n// Static constants\nMIDIFileTrack.HDR_LENGTH = 8;\n\n// Track length\nMIDIFileTrack.prototype.getTrackLength = function() {\n  return this.datas.getUint32(4);\n};\n\nMIDIFileTrack.prototype.setTrackLength = function(trackLength) {\n  return this.datas.setUint32(4, trackLength);\n};\n\n// Read track contents\nMIDIFileTrack.prototype.getTrackContent = function() {\n  return new DataView(\n    this.datas.buffer,\n    this.datas.byteOffset + MIDIFileTrack.HDR_LENGTH,\n    this.datas.byteLength - MIDIFileTrack.HDR_LENGTH\n  );\n};\n\n// Set track content\nMIDIFileTrack.prototype.setTrackContent = function(dataView) {\n  let origin;\n  let destination;\n  let i;\n  let j;\n  // Calculating the track length\n  const trackLength = dataView.byteLength - dataView.byteOffset;\n\n  // Track length must size at least like an  empty track (4bytes)\n  if (trackLength < 4) {\n    throw new Error(\"Invalid track length, must size at least 4bytes\");\n  }\n  this.datas = new DataView(\n    new Uint8Array(MIDIFileTrack.HDR_LENGTH + trackLength).buffer\n  );\n  // Adding the track header (MTrk)\n  this.datas.setUint8(0, 0x4d); // M\n  this.datas.setUint8(1, 0x54); // T\n  this.datas.setUint8(2, 0x72); // r\n  this.datas.setUint8(3, 0x6b); // k\n  // Adding the track size\n  this.datas.setUint32(4, trackLength);\n  // Copying the content\n  origin = new Uint8Array(\n    dataView.buffer,\n    dataView.byteOffset,\n    dataView.byteLength\n  );\n  destination = new Uint8Array(\n    this.datas.buffer,\n    MIDIFileTrack.HDR_LENGTH,\n    trackLength\n  );\n  for (i = 0, j = origin.length; i < j; i++) {\n    destination[i] = origin[i];\n  }\n};\n\n// /...........................................\n\n// MIDIFile : Read (and soon edit) a MIDI file in a given ArrayBuffer\n\nfunction ensureArrayBuffer(buf) {\n  if (buf) {\n    if (buf instanceof ArrayBuffer) {\n      return buf;\n    }\n    if (buf instanceof Uint8Array) {\n      // Copy/convert to standard Uint8Array, because derived classes like\n      // node.js Buffers might have unexpected data in the .buffer property.\n      return new Uint8Array(buf).buffer;\n    }\n  }\n  throw new Error(\"Unsupported buffer type, need ArrayBuffer or Uint8Array\");\n}\n\n// Constructor\nfunction MIDIFile(buffer, strictMode) {\n  let track;\n  let curIndex;\n  let i;\n  let j;\n\n  // If not buffer given, creating a new MIDI file\n  if (!buffer) {\n    // Creating the content\n    this.header = new MIDIFileHeader();\n    this.tracks = [new MIDIFileTrack()];\n    // if a buffer is provided, parsing him\n  } else {\n    buffer = ensureArrayBuffer(buffer);\n    // Minimum MIDI file size is a headerChunk size (14bytes)\n    // and an empty track (8+3bytes)\n    if (buffer.byteLength < 25) {\n      throw new Error(\n        \"A buffer of a valid MIDI file must have, at least, a\" +\n          \" size of 25bytes.\"\n      );\n    }\n    // Reading header\n    this.header = new MIDIFileHeader(buffer, strictMode);\n    this.tracks = [];\n    curIndex = MIDIFileHeader.HEADER_LENGTH;\n    // Reading tracks\n    for (i = 0, j = this.header.getTracksCount(); i < j; i++) {\n      // Testing the buffer length\n      if (strictMode && curIndex >= buffer.byteLength - 1) {\n        throw new Error(\n          `Couldn\"t find datas corresponding to the track #${i}.`\n        );\n      }\n      // Creating the track object\n      track = new MIDIFileTrack(buffer, curIndex, strictMode);\n      this.tracks.push(track);\n      // Updating index to the track end\n      curIndex += track.getTrackLength() + 8;\n    }\n    // Testing integrity : curIndex should be at the end of the buffer\n    if (strictMode && curIndex !== buffer.byteLength) {\n      throw new Error(\"It seems that the buffer contains too much datas.\");\n    }\n  }\n}\nMIDIFile.prototype.startNote = function(event, song) {\n  const track = this.takeTrack(event.channel, song);\n  track.notes.push({\n    when: event.playTime / 1000,\n    pitch: event.param1,\n    duration: 0.0000001,\n    slides: [],\n  });\n};\nMIDIFile.prototype.closeNote = function(event, song) {\n  const track = this.takeTrack(event.channel, song);\n  for (let i = 0; i < track.notes.length; i++) {\n    if (\n      track.notes[i].duration == 0.0000001 && //\n      track.notes[i].pitch == event.param1 && //\n      track.notes[i].when < event.playTime / 1000\n    ) {\n      track.notes[i].duration = event.playTime / 1000 - track.notes[i].when;\n      break;\n    }\n  }\n};\nMIDIFile.prototype.addSlide = function(event, song) {\n  const track = this.takeTrack(event.channel, song);\n  for (let i = 0; i < track.notes.length; i++) {\n    if (\n      track.notes[i].duration == 0.0000001 && //\n      track.notes[i].when < event.playTime / 1000\n    ) {\n      // if (Math.abs(track.notes[i].shift) < Math.abs(event.param2 - 64) / 6) {\n      // track.notes[i].shift = (event.param2 - 64) / 6;\n      // console.log(event.param2-64);\n      // }\n      track.notes[i].slides.push({\n        pitch: track.notes[i].pitch + (event.param2 - 64) / 6,\n        when: event.playTime / 1000 - track.notes[i].when,\n      });\n    }\n  }\n};\nMIDIFile.prototype.startDrum = function(event, song) {\n  const beat = this.takeBeat(event.param1, song);\n  beat.notes.push({\n    when: event.playTime / 1000,\n  });\n};\nMIDIFile.prototype.takeTrack = function(n, song) {\n  for (let i = 0; i < song.tracks.length; i++) {\n    if (song.tracks[i].n == n) {\n      return song.tracks[i];\n    }\n  }\n  const track = {\n    n,\n    notes: [],\n    volume: 1,\n    program: 0,\n  };\n  song.tracks.push(track);\n  return track;\n};\nMIDIFile.prototype.takeBeat = function(n, song) {\n  for (let i = 0; i < song.beats.length; i++) {\n    if (song.beats[i].n == n) {\n      return song.beats[i];\n    }\n  }\n  const beat = {\n    n,\n    notes: [],\n    volume: 1,\n  };\n  song.beats.push(beat);\n  return beat;\n};\nMIDIFile.prototype.parseSong = function() {\n  const song = {\n    duration: 0,\n    tracks: [],\n    beats: [],\n  };\n  const events = this.getMidiEvents();\n  // console.log(events);\n  for (let i = 0; i < events.length; i++) {\n    // console.log(\"\t\tnext\",events[i]);\n    if (song.duration < events[i].playTime / 1000) {\n      song.duration = events[i].playTime / 1000;\n    }\n    if (events[i].subtype == MIDIEvents.EVENT_MIDI_NOTE_ON) {\n      if (events[i].channel == 9) {\n        if (events[i].param1 >= 35 && events[i].param1 <= 81) {\n          this.startDrum(events[i], song);\n        } else {\n          console.log(\"wrong drum\", events[i]);\n        }\n      } else if (events[i].param1 >= 0 && events[i].param1 <= 127) {\n        // console.log(\"start\", events[i].param1);\n        this.startNote(events[i], song);\n      } else {\n        console.log(\"wrong tone\", events[i]);\n      }\n    } else if (events[i].subtype == MIDIEvents.EVENT_MIDI_NOTE_OFF) {\n      if (events[i].channel != 9) {\n        this.closeNote(events[i], song);\n        // console.log(\"close\", events[i].param1);\n      }\n    } else if (events[i].subtype == MIDIEvents.EVENT_MIDI_PROGRAM_CHANGE) {\n      if (events[i].channel != 9) {\n        var track = this.takeTrack(events[i].channel, song);\n        track.program = events[i].param1;\n      } else {\n        console.log(\"skip program for drums\");\n      }\n    } else if (events[i].subtype == MIDIEvents.EVENT_MIDI_CONTROLLER) {\n      if (events[i].param1 == 7) {\n        if (events[i].channel != 9) {\n          var track = this.takeTrack(events[i].channel, song);\n          track.volume = events[i].param2 / 127 || 0.000001;\n          // console.log(\"volume\", track.volume,\"for\",events[i].channel);\n        }\n      } else {\n        // console.log(\"controller\", events[i]);\n      }\n    } else if (events[i].subtype == MIDIEvents.EVENT_MIDI_PITCH_BEND) {\n      // console.log(\"\tbend\", events[i].channel, events[i].param1, events[i].param2);\n      this.addSlide(events[i], song);\n    } else {\n      console.log(\"unknown\", events[i].channel, events[i]);\n    }\n  }\n  return song;\n};\n// Events reading helpers\nMIDIFile.prototype.getEvents = function(type, subtype) {\n  let events;\n  let event;\n  let playTime = 0;\n  const filteredEvents = [];\n  const format = this.header.getFormat();\n  let tickResolution = this.header.getTickResolution();\n  let i;\n  let j;\n  let trackParsers;\n  let smallestDelta;\n\n  // Reading events\n  // if the read is sequential\n  if (format !== 1 || this.tracks.length === 1) {\n    for (i = 0, j = this.tracks.length; i < j; i++) {\n      // reset playtime if format is 2\n      playTime = format === 2 && playTime ? playTime : 0;\n      events = MIDIEvents.createParser(\n        this.tracks[i].getTrackContent(),\n        0,\n        false\n      );\n      // loooping through events\n      event = events.next();\n      while (event) {\n        playTime += event.delta ? (event.delta * tickResolution) / 1000 : 0;\n        if (event.type === MIDIEvents.EVENT_META) {\n          // tempo change events\n          if (event.subtype === MIDIEvents.EVENT_META_SET_TEMPO) {\n            tickResolution = this.header.getTickResolution(event.tempo);\n          }\n        }\n        // push the asked events\n        if (\n          (!type || event.type === type) &&\n          (!subtype || (event.subtype && event.subtype === subtype))\n        ) {\n          event.playTime = playTime;\n          filteredEvents.push(event);\n        }\n        event = events.next();\n      }\n    }\n    // the read is concurrent\n  } else {\n    trackParsers = [];\n    smallestDelta = -1;\n\n    // Creating parsers\n    for (i = 0, j = this.tracks.length; i < j; i++) {\n      trackParsers[i] = {};\n      trackParsers[i].parser = MIDIEvents.createParser(\n        this.tracks[i].getTrackContent(),\n        0,\n        false\n      );\n      trackParsers[i].curEvent = trackParsers[i].parser.next();\n    }\n    // Filling events\n    do {\n      smallestDelta = -1;\n      // finding the smallest event\n      for (i = 0, j = trackParsers.length; i < j; i++) {\n        if (trackParsers[i].curEvent) {\n          if (\n            smallestDelta === -1 ||\n            trackParsers[i].curEvent.delta <\n              trackParsers[smallestDelta].curEvent.delta\n          ) {\n            smallestDelta = i;\n          }\n        }\n      }\n      if (smallestDelta !== -1) {\n        // removing the delta of previous events\n        for (i = 0, j = trackParsers.length; i < j; i++) {\n          if (i !== smallestDelta && trackParsers[i].curEvent) {\n            trackParsers[i].curEvent.delta -=\n              trackParsers[smallestDelta].curEvent.delta;\n          }\n        }\n        // filling values\n        event = trackParsers[smallestDelta].curEvent;\n        playTime += event.delta ? (event.delta * tickResolution) / 1000 : 0;\n        if (event.type === MIDIEvents.EVENT_META) {\n          // tempo change events\n          if (event.subtype === MIDIEvents.EVENT_META_SET_TEMPO) {\n            tickResolution = this.header.getTickResolution(event.tempo);\n          }\n        }\n        // push midi events\n        if (\n          (!type || event.type === type) &&\n          (!subtype || (event.subtype && event.subtype === subtype))\n        ) {\n          event.playTime = playTime;\n          event.track = smallestDelta;\n          filteredEvents.push(event);\n        }\n        // getting next event\n        trackParsers[smallestDelta].curEvent = trackParsers[\n          smallestDelta\n        ].parser.next();\n      }\n    } while (smallestDelta !== -1);\n  }\n  return filteredEvents;\n};\n\nMIDIFile.prototype.getMidiEvents = function() {\n  return this.getEvents(MIDIEvents.EVENT_MIDI);\n};\n\nMIDIFile.prototype.getLyrics = function() {\n  const events = this.getEvents(MIDIEvents.EVENT_META);\n  let texts = [];\n  const lyrics = [];\n  let event;\n  let i;\n  let j;\n\n  for (i = 0, j = events.length; i < j; i++) {\n    event = events[i];\n    // Lyrics\n    if (event.subtype === MIDIEvents.EVENT_META_LYRICS) {\n      lyrics.push(event);\n      // Texts\n    } else if (event.subtype === MIDIEvents.EVENT_META_TEXT) {\n      // Ignore special texts\n      if (String.fromCharCode(event.data[0]) === \"@\") {\n        if (String.fromCharCode(event.data[1]) === \"T\") {\n          // console.log(\"Title : \" + event.text.substring(2));\n        } else if (String.fromCharCode(event.data[1]) === \"I\") {\n          // console.log(\"Info : \" + event.text.substring(2));\n        } else if (String.fromCharCode(event.data[1]) === \"L\") {\n          // console.log(\"Lang : \" + event.text.substring(2));\n        }\n        // karaoke text follows, remove all previous text\n      } else if (String.fromCharCode(...event.data).indexOf(\"words\") === 0) {\n        texts.length = 0;\n        // console.log(\"Word marker found\");\n        // Karaoke texts\n        // If playtime is greater than 0\n      } else if (event.playTime !== 0) {\n        texts.push(event);\n      }\n    }\n  }\n  // Choosing the right lyrics\n  if (lyrics.length > 2) {\n    texts = lyrics;\n  } else if (!texts.length) {\n    texts = [];\n  }\n  // Convert texts and detect encoding\n  try {\n    texts.forEach(event => {\n      event.text = UTF8.getStringFromBytes(event.data, 0, event.length, true);\n    });\n  } catch (e) {\n    texts.forEach(event => {\n      event.text = event.data.map(c => String.fromCharCode(c)).join(\"\");\n    });\n  }\n  return texts;\n};\n\n// Basic events reading\nMIDIFile.prototype.getTrackEvents = function(index) {\n  let event;\n  const events = [];\n  let parser;\n  if (index > this.tracks.length || index < 0) {\n    throw Error(`Invalid track index (${index})`);\n  }\n  parser = MIDIEvents.createParser(\n    this.tracks[index].getTrackContent(),\n    0,\n    false\n  );\n  event = parser.next();\n  do {\n    events.push(event);\n    event = parser.next();\n  } while (event);\n  return events;\n};\n\n// Basic events writting\nMIDIFile.prototype.setTrackEvents = function(index, events) {\n  let bufferLength;\n  let destination;\n\n  if (index > this.tracks.length || index < 0) {\n    throw Error(`Invalid track index (${index})`);\n  }\n  if (!events || !events.length) {\n    throw Error(\"A track must contain at least one event, none given.\");\n  }\n  bufferLength = MIDIEvents.getRequiredBufferLength(events);\n  destination = new Uint8Array(bufferLength);\n  MIDIEvents.writeToTrack(events, destination);\n  this.tracks[index].setTrackContent(destination);\n};\n\n// Remove a track\nMIDIFile.prototype.deleteTrack = function(index) {\n  if (index > this.tracks.length || index < 0) {\n    throw Error(`Invalid track index (${index})`);\n  }\n  this.tracks.splice(index, 1);\n  this.header.setTracksCount(this.tracks.length);\n};\n\n// Add a track\nMIDIFile.prototype.addTrack = function(index) {\n  let track;\n\n  if (index > this.tracks.length || index < 0) {\n    throw Error(`Invalid track index (${index})`);\n  }\n  track = new MIDIFileTrack();\n  if (index === this.tracks.length) {\n    this.tracks.push(track);\n  } else {\n    this.tracks.splice(index, 0, track);\n  }\n  this.header.setTracksCount(this.tracks.length);\n};\n\n// Retrieve the content in a buffer\nMIDIFile.prototype.getContent = function() {\n  let bufferLength;\n  let destination;\n  let origin;\n  let i;\n  let j;\n  let k;\n  let l;\n  let m;\n  let n;\n\n  // Calculating the buffer content\n  // - initialize with the header length\n  bufferLength = MIDIFileHeader.HEADER_LENGTH;\n  // - add tracks length\n  for (i = 0, j = this.tracks.length; i < j; i++) {\n    bufferLength += this.tracks[i].getTrackLength() + 8;\n  }\n  // Creating the destination buffer\n  destination = new Uint8Array(bufferLength);\n  // Adding header\n  origin = new Uint8Array(\n    this.header.datas.buffer,\n    this.header.datas.byteOffset,\n    MIDIFileHeader.HEADER_LENGTH\n  );\n  for (i = 0, j = MIDIFileHeader.HEADER_LENGTH; i < j; i++) {\n    destination[i] = origin[i];\n  }\n  // Adding tracks\n  for (k = 0, l = this.tracks.length; k < l; k++) {\n    origin = new Uint8Array(\n      this.tracks[k].datas.buffer,\n      this.tracks[k].datas.byteOffset,\n      this.tracks[k].datas.byteLength\n    );\n    for (m = 0, n = this.tracks[k].datas.byteLength; m < n; m++) {\n      destination[i++] = origin[m];\n    }\n  }\n  return destination.buffer;\n};\n\n// Exports Track/Header constructors\nMIDIFile.Header = MIDIFileHeader;\nMIDIFile.Track = MIDIFileTrack;\n\nexport default MIDIFile;\n","// @flow\n\nimport React, { Component } from \"react\";\nimport axios from \"axios\";\nimport { Box, CheckBox, Text } from \"grommet\";\nimport { Music } from \"grommet-icons\";\nimport cache from \"./utils/ScriptCache\";\nimport { SCRIPTS } from \"./constants\";\nimport { ScoreProvider, ScoreConsumer } from \"./context\";\nimport MusicPlayer from \"./components/MusicPlayer\";\n\ntype Props = {\n  page: Object,\n};\n\ntype State = {\n  error: boolean,\n  errorMessage: ?string,\n  musicScore: ?string,\n  musicScoreSvg: ?HTMLDivElement,\n  midi: ?string,\n  isLoaded: boolean,\n  scriptCache: any,\n  currentPage: number,\n  totalPages: number,\n};\n\nconst ScoreView = () => (\n  <ScoreConsumer>\n    {({ isLoaded, error, musicScoreSvg }) =>\n      isLoaded && !error ? (\n        <Box\n          background=\"none\"\n          animation=\"fadeIn\"\n          margin=\"small\"\n          dangerouslySetInnerHTML={{ __html: musicScoreSvg }}\n        />\n      ) : (\n        <Box\n          align=\"center\"\n          alignContent=\"center\"\n          animation=\"fadeIn\"\n          justify=\"center\"\n          height=\"210px\"\n          round=\"small\"\n          margin=\"small\"\n          background=\"light-2\"\n        >\n          <Music />\n          <Text margin=\"small\" color=\"dark-5\">\n            Loading Music Score...\n          </Text>\n        </Box>\n      )\n    }\n  </ScoreConsumer>\n);\n\nconst Wrapper = () => WrappedComponent => {\n  class ScoreWrapper extends Component<Props, State> {\n    state = {\n      error: false,\n      errorMessage: \"\",\n      musicScore: null,\n      musicScoreSvg: null,\n      midi: null,\n      page: {},\n      isLoaded: false,\n      scriptCache: {},\n      currentPage: 1,\n      totalPages: 0,\n      visibleOptions: {\n        note: true,\n        tick: true,\n        measure: true,\n      },\n    };\n\n    updateScoreFollowingMIDI = this.updateScoreFollowingMIDI.bind(this);\n\n    vrvToolkit: Object = {};\n\n    static getDerivedStateFromProps(state: State, props) {\n      if (!state.scriptCache) {\n        return {\n          scriptCache: cache({\n            verovio: SCRIPTS.verovio,\n          }),\n        };\n      }\n\n      if (props.page !== state.page) {\n        return {\n          page: props.page,\n        };\n      }\n      return null;\n    }\n\n    componentDidMount() {\n      this.fetchScoreData();\n      this.initVrvToolkit();\n      document.addEventListener(\"keydown\", this.handleKeyPress, false);\n    }\n\n    componentDidUpdate(prevProps: Props) {\n      const { isLoaded } = this.state;\n      const { page } = this.props;\n      if (page !== prevProps.page && isLoaded) {\n        this.reloadScoreSVG();\n      }\n    }\n\n    componentWillUnmount() {\n      document.removeEventListener(\"keydown\", this.handleKeyPress, false);\n    }\n\n    setScoreOption() {\n      const { page } = this.props;\n      const options = {\n        pageHeight: (page.height * 100) / page.zoom,\n        pageWidth: (page.width * 100) / page.zoom,\n        scale: page.zoom,\n        adjustPageHeight: true,\n      };\n      this.vrvToolkit && page && this.vrvToolkit.setOptions(options);\n    }\n\n    handleKeyPress = (e: KeyboardEvent) => {\n      e = e || window.event;\n      const type = e.key;\n\n      const arrowKeys = {\n        ArrowLeft: () => this.movePrevPage(),\n        ArrowRight: () => this.moveNextPage(),\n        ArrowUp: () => {},\n        ArrowDown: () => {},\n        default: () => {},\n      };\n      (arrowKeys[type] || arrowKeys.default)();\n    };\n\n    initScorePage(pageNum: number = 1) {\n      if (this.vrvToolkit) {\n        this.setScoreOption();\n        this.vrvToolkit.redoLayout();\n        const musicScoreSvg = this.vrvToolkit.renderToSVG(pageNum, {});\n        const totalPages = this.vrvToolkit.getPageCount();\n        const midi = `${this.vrvToolkit.renderToMIDI()}`;\n\n        this.setState({\n          musicScoreSvg,\n          midi,\n          totalPages,\n        });\n      }\n    }\n\n    reloadScoreSVG(pageNum: number = 1) {\n      if (this.vrvToolkit) {\n        this.setScoreOption();\n        this.vrvToolkit.redoLayout();\n        const musicScoreSvg = this.vrvToolkit.renderToSVG(pageNum, {});\n        this.setState({\n          musicScoreSvg,\n        });\n      }\n    }\n\n    moveNextPage() {\n      const { currentPage, totalPages } = this.state;\n      if (currentPage < totalPages) {\n        this.setState(prevState => ({\n          currentPage: prevState.currentPage + 1,\n        }));\n        this.reloadScoreSVG(currentPage + 1);\n      }\n    }\n\n    goToPage(page: number = 1) {\n      this.setState({\n        currentPage: page,\n      });\n      this.reloadScoreSVG(page);\n    }\n\n    movePrevPage() {\n      const { currentPage } = this.state;\n      if (currentPage > 1) {\n        this.setState(prevState => ({\n          currentPage: prevState.currentPage - 1,\n        }));\n        this.reloadScoreSVG(currentPage - 1);\n      }\n    }\n\n    fetchScoreData() {\n      axios({\n        method: \"get\",\n        url: \"/static/chopin10_3.mei\",\n        responseType: \"text\",\n      })\n        .then(response => {\n          this.setState({\n            musicScore: response.data,\n          });\n        })\n        .catch(error => {\n          this.setState({\n            error: true,\n            errorMessage: error,\n          });\n        });\n    }\n\n    initVrvToolkit() {\n      const { scriptCache } = this.state;\n      scriptCache &&\n        scriptCache.verovio.onLoad((err, tag) => {\n          this.setState(\n            {\n              error: tag.error,\n              isLoaded: true,\n            },\n            () => {\n              this.vrvToolkit = new window.verovio.toolkit();\n              if (this.vrvToolkit) {\n                this.loadScore();\n              }\n            }\n          );\n        });\n    }\n\n    loadScore() {\n      const { musicScore } = this.state;\n      this.vrvToolkit.loadData(musicScore);\n      this.initScorePage();\n    }\n\n    updateScoreFollowingMIDI(notesArr: Array<string>, page: number) {\n      const { currentPage } = this.state;\n      if (page !== currentPage) {\n        this.goToPage(page);\n      }\n    }\n\n    render() {\n      const { midi } = this.state;\n      return (\n        <div>\n          <ScoreProvider value={this.state}>\n            <ScoreStatusBar />\n            <WrappedComponent />\n          </ScoreProvider>\n          <MusicPlayer\n            vrvToolkit={this.vrvToolkit}\n            updateScore={this.updateScoreFollowingMIDI}\n            getElementsAtTime={this.vrvToolkit.getElementsAtTime}\n            midi={midi}\n          />\n        </div>\n      );\n    }\n  }\n\n  return ScoreWrapper;\n};\n\nconst ScoreStatusBar = () => (\n  <Box direction=\"row\" justify=\"between\">\n    <Measure />\n    <ScoreViewOptions />\n  </Box>\n);\n\nconst Measure = () => (\n  <ScoreConsumer>\n    {({ totalPages, currentPage }) => (\n      <Box direction=\"row\">\n        <Text color=\"accent-1\">{currentPage}</Text>\n        <Text>/ {totalPages}</Text>\n      </Box>\n    )}\n  </ScoreConsumer>\n);\n\nconst ScoreViewOptions = () => (\n  <ScoreConsumer>\n    {({ visibleOptions }) => (\n      <Box gap=\"small\" direction=\"row\" justify=\"between\">\n        {Object.keys(visibleOptions).map(option => (\n          <CheckBox\n            key={option}\n            // checked={visibleOptions[option]}\n            label={<Text>{option}</Text>}\n          />\n        ))}\n      </Box>\n    )}\n  </ScoreConsumer>\n);\n\nexport default Wrapper()(ScoreView);\n","// @flow\nimport React, { Component } from \"react\";\nimport { Box, Meter, Button } from \"grommet\";\nimport { Play, Pause, Volume, VolumeLow, VolumeMute } from \"grommet-icons\";\nimport MIDISounds from \"midi-sounds-react\";\nimport MIDIFile from \"../../MIDIFile\";\nimport { MusicPlayerProvider, MusicPlayerConsumer } from \"../../context\";\n\nconst base64ToArrayBuffer = (base64: string): ArrayBuffer => {\n  const binaryString = window.atob(base64);\n  const len = binaryString.length;\n  const bytes = new Uint8Array(len);\n  for (let i = 0; i < len; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes.buffer;\n};\n\nconst findFirstIns = (player: Object, nn: Object): ?number => {\n  for (let i = 0; i < player.loader.instrumentKeys().length; i++) {\n    if (nn === 1 * player.loader.instrumentKeys()[i].substring(0, 3)) {\n      return i;\n    }\n  }\n};\n\ntype Props = {\n  midi: ?string,\n  updateScore: (notesArr: Array<string>, page: number) => any,\n  vrvToolkit: Object,\n};\n\ntype State = {\n  currentSongTime: number,\n  reverberator: ?Object,\n  isPlayed: boolean,\n  leftTime: number,\n  nextPositionTime: number,\n  nextStepTime: number,\n  playMode: string,\n  player: any,\n  playing: boolean,\n  progress: number,\n  song: {\n    beats: Array<Object>,\n    duration: number,\n    tracks: Array<Object>,\n  },\n  songStart: number,\n  volume: number,\n};\n\nclass MusicPlayer extends Component<Props, State> {\n  state = {\n    currentSongTime: 0,\n    reverberator: {},\n    isPlayed: false,\n    leftTime: 0,\n    nextPositionTime: 0,\n    nextStepTime: 0,\n    playMode: \"loop\",\n    player: {},\n    playing: false,\n    progress: 0,\n    song: {\n      beats: [],\n      duration: 0,\n      tracks: [],\n    },\n    songStart: 0,\n    volume: 1,\n  };\n\n  audioContextFunc: window = window.AudioContext || window.webkitAudioContext;\n\n  audioContext: Object = new this.audioContextFunc();\n\n  midiFile: Object = new MIDIFile();\n\n  midiSoundsRef: Object = React.createRef();\n\n  scrubberRef: ?Object = React.createRef();\n\n  stepDuration: number = 0.5;\n\n  handleAdjustPlay: () => void = this.handleAdjustPlay.bind(this);\n\n  componentDidUpdate(prevProps: Props, prevState: State) {\n    const { song, playing, currentSongTime } = this.state;\n    const { midi, updateScore, vrvToolkit } = this.props;\n    if (midi !== prevProps.midi) {\n      this.parseMIDISong();\n    }\n    if (song !== prevState.song) {\n      this.startLoad();\n    }\n    if (playing !== prevState.playing) {\n      this.startPlay();\n    }\n    if (currentSongTime !== prevState.currentSongTime) {\n      // console.log(this.props.moveNextPage());\n      const vrvTime = Math.max(0, currentSongTime * 1000);\n      const vrvEle = vrvToolkit.getElementsAtTime(vrvTime);\n      return updateScore(vrvEle.notes, vrvEle.page);\n    }\n  }\n\n  startPlay = () => {\n    const { isPlayed, song, progress, player } = this.state;\n    player.cancelQueue(this.audioContext);\n    if (isPlayed) {\n      const next = (song.duration * progress) / 100;\n      this.setState(prevState => ({\n        songStart: prevState.songStart - (next - prevState.currentSongTime),\n        currentSongTime: next,\n      }));\n    } else {\n      // init\n      this.setState(prevState => ({\n        isPlayed: !prevState.isPlayed,\n        currentSongTime: 0,\n        songStart: this.audioContext.currentTime,\n        nextStepTime: this.audioContext.currentTime,\n      }));\n    }\n    return this.tick();\n  };\n\n  handleAdjustVolume = () => {\n    this.setState(prevState => ({\n      volume: prevState.volume === 2 ? 0 : prevState.volume + 1,\n    }));\n  };\n\n  tick = () => {\n    const { currentSongTime, nextStepTime, song, playing } = this.state;\n    if (!playing || !song) {\n      return;\n    }\n    if (this.audioContext.currentTime > nextStepTime - this.stepDuration) {\n      this.sendNotes(currentSongTime, currentSongTime + this.stepDuration);\n      this.setState((prevState: State) => ({\n        progress: Math.round(\n          (100 * prevState.currentSongTime) / prevState.song.duration\n        ),\n        currentSongTime: prevState.currentSongTime + this.stepDuration,\n        nextStepTime: prevState.nextStepTime + this.stepDuration,\n      }));\n\n      // end Song\n      if (currentSongTime > song.duration) {\n        this.setState({\n          progress: 0,\n          playing: false,\n          isPlayed: false,\n          currentSongTime: 0,\n          songStart: 0,\n        });\n      }\n    }\n\n    window.requestAnimationFrame(() => {\n      this.tick();\n    });\n  };\n\n  sendNotes = (start: number, end: number) => {\n    const { song, songStart, reverberator, player } = this.state;\n    if (!song) {\n      return;\n    }\n\n    for (let t = 0; t < song.tracks.length; t++) {\n      const track = song.tracks[t];\n      for (let i = 0; i < track.notes.length; i++) {\n        if (track.notes[i].when >= start && track.notes[i].when < end) {\n          const when = songStart + track.notes[i].when;\n          let { duration } = track.notes[i];\n          if (duration > 3) {\n            duration = 3;\n          }\n          const instr = track.info.variable;\n          const v = track.volume / 7;\n          player &&\n            player.queueWaveTable(\n              this.audioContext,\n              reverberator,\n              window[instr],\n              when,\n              track.notes[i].pitch,\n              duration,\n              v,\n              track.notes[i].slides\n            );\n        }\n      }\n    }\n\n    for (let b = 0; b < song.beats.length; b++) {\n      const beat = song.beats[b];\n      for (let i = 0; i < beat.notes.length; i++) {\n        if (beat.notes[i].when >= start && beat.notes[i].when < end) {\n          const when = songStart + beat.notes[i].when;\n          const duration = 1.5;\n          const instr = beat.info.variable;\n          const v = beat.volume / 2;\n          player &&\n            player.queueWaveTable(\n              this.audioContext,\n              reverberator,\n              window[instr],\n              when,\n              beat.n,\n              duration,\n              v\n            );\n        }\n      }\n    }\n  };\n\n  seek = (e: MouseEvent) => {\n    const { player, song } = this.state;\n    player.cancelQueue(this.audioContext);\n    if (this.scrubberRef) {\n      const scrubberRect = this.scrubberRef.getBoundingClientRect();\n      const percent =\n        ((e.clientX - scrubberRect.left) / scrubberRect.width) * 100;\n      const next = (song.duration * percent) / 100;\n      this.setState((prevState: State) => ({\n        progress: percent,\n        playing: true,\n        songStart: prevState.songStart - (next - prevState.currentSongTime),\n        currentSongTime: next,\n      }));\n    }\n  };\n\n  parseMIDISong = () => {\n    const { midi } = this.props;\n    if (midi) {\n      const arrayBuffer = base64ToArrayBuffer(midi);\n      const midiFile = new MIDIFile(arrayBuffer);\n      const song = midiFile.parseSong();\n      this.setState({ song });\n    }\n  };\n\n  startLoad = () => {\n    this.midiSoundsRef.current &&\n      this.setState({ player: this.midiSoundsRef.current.player }, () => {\n        const { song, player } = this.state;\n        const reverberator = player.createReverberator(this.audioContext);\n        reverberator.output.connect(this.audioContext.destination);\n        this.setState({ reverberator: reverberator.input });\n        // set Instrument to every track\n        for (let i = 0; i < song.tracks.length; i++) {\n          const nn = findFirstIns(player, song.tracks[i].program);\n          const info = player.loader.instrumentInfo(nn);\n          song.tracks[i].info = info;\n          song.tracks[i].id = nn;\n          player.loader.startLoad(this.audioContext, info.url, info.variable);\n        }\n      });\n  };\n\n  handleAdjustPlay() {\n    this.setState(prevState => ({\n      playing: !prevState.playing,\n    }));\n  }\n\n  render() {\n    return (\n      <MusicPlayerProvider value={this.state}>\n        <Box direction=\"row\" align=\"center\" justify=\"between\">\n          <PlayButton onClick={this.handleAdjustPlay} />\n          <Box\n            direction=\"row\"\n            align=\"center\"\n            flex\n            ref={e => {\n              this.scrubberRef = e;\n            }}\n          >\n            <AudioProgressBar onClick={this.seek} />\n          </Box>\n          <Box>\n            <VolumeButton onClick={() => this.handleAdjustVolume()} />\n          </Box>\n        </Box>\n        <MIDISounds appElementName=\"root\" ref={this.midiSoundsRef} />\n      </MusicPlayerProvider>\n    );\n  }\n}\n\nconst PlayButton = ({ onClick }) => (\n  <MusicPlayerConsumer>\n    {({ playing }) => (\n      <Button\n        hoverIndicator=\"background\"\n        icon={playing ? <Pause /> : <Play />}\n        onClick={onClick}\n      />\n    )}\n  </MusicPlayerConsumer>\n);\n\nconst VolumeButton = ({ onClick }) => {\n  const icons = [<VolumeMute />, <VolumeLow />, <Volume />];\n  return (\n    <MusicPlayerConsumer>\n      {({ volume }) => (\n        <Button\n          hoverIndicator=\"background\"\n          icon={icons[volume]}\n          onClick={onClick}\n        />\n      )}\n    </MusicPlayerConsumer>\n  );\n};\n\nconst AudioProgressBar = ({ onClick }) => (\n  <MusicPlayerConsumer>\n    {({ progress }) => (\n      <Meter\n        aria-label=\"Audio progress\"\n        type=\"bar\"\n        size=\"full\"\n        onClick={onClick}\n        thickness=\"small\"\n        values={[\n          {\n            color: \"accent-1\",\n            value: progress,\n          },\n        ]}\n      />\n    )}\n  </MusicPlayerConsumer>\n);\n\nexport default MusicPlayer;\n","import MusicPlayer from \"./MusicPlayer\";\n\nexport default MusicPlayer;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA.\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      if (\n        response.status === 404 ||\n        response.headers.get('content-type').indexOf('javascript') === -1\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport \"./index.css\";\nimport { Grid, Grommet, Heading, Box, Paragraph } from \"grommet\";\nimport { grommet, hpe, dark } from \"grommet/themes\";\n\nimport MusicScore from \"./MusicScore\";\nimport * as serviceWorker from \"./serviceWorker\";\n\n// if (process.env.NODE_ENV !== \"production\") {\n//   const { whyDidYouUpdate } = require(\"why-did-you-update\");\n//   whyDidYouUpdate(React);\n// }\n\nconst THEMES = {\n  grommet,\n  hpe,\n  dark,\n};\n\nconst measureElement = element => ({\n  width: element.current.getBoundingClientRect().width,\n  height: element.current.getBoundingClientRect().height,\n});\n\nclass App extends React.Component {\n  scoreEL = React.createRef();\n\n  pageEl = React.createRef();\n\n  state = {\n    scoreView: {\n      height: 0,\n      width: 0,\n      zoom: 40,\n    },\n  };\n\n  componentDidMount() {\n    this.onScoreSizeChange();\n    window.addEventListener(\"resize\", this.onScoreSizeChange.bind(this));\n  }\n\n  onScoreSizeChange() {\n    const result = measureElement(this.scoreEL);\n    const { scoreView } = this.state;\n    this.setState({\n      scoreView: { ...scoreView, ...result },\n    });\n  }\n\n  render() {\n    const themeName = \"grommet\";\n    const { scoreView } = this.state;\n    return (\n      <Grommet theme={THEMES[themeName || \"grommet\"]}>\n        <Box>\n          <Grid\n            margin=\"small\"\n            areas={[\n              { name: \"header\", start: [0, 0], end: [1, 0] },\n              { name: \"main\", start: [0, 1], end: [1, 1] },\n              { name: \"foot\", start: [0, 2], end: [1, 2] },\n\n              // { name: \"header\", start: [0, 0], end: [1, 0] },\n              // { name: \"main\", start: [0, 1], end: [0, 1] },\n              // { name: \"control\", start: [1, 1], end: [1, 1] },\n              // { name: \"foot\", start: [0, 2], end: [1, 2] },\n            ]}\n            columns={[\"auto\"]}\n            rows={[\"auto\", \"auto\", \"auto\"]}\n          >\n            <Box direction=\"row\" gridArea=\"header\">\n              <Box pad={{ between: \"medium\" }}>\n                <Heading color=\"brand\" level={3} responsive textAlign=\"center\">\n                  MIDI performance Visualization\n                </Heading>\n              </Box>\n            </Box>\n            <Box ref={this.scoreEL} gridArea=\"main\">\n              <MusicScore page={scoreView} />\n            </Box>\n            <Box gridArea=\"foot\" background=\"dark\">\n              <Box>\n                <Paragraph margin=\"none\">©</Paragraph>\n              </Box>\n            </Box>\n          </Grid>\n        </Box>\n      </Grommet>\n    );\n  }\n}\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n\nif (module.hot) {\n  module.hot.accept();\n}\n\nserviceWorker.unregister();\n","let counter = 0;\nconst scriptMap = new Map();\n\nfunction ScriptCache(scripts) {\n  const Cache = {};\n\n  Cache.onLoad = key => cb => {\n    const stored = scriptMap.get(key);\n    if (stored) {\n      stored.promise.then(() => {\n        stored.error ? cb(stored.error) : cb(null, stored);\n      });\n    } else {\n      // TODO:\n    }\n  };\n\n  Cache.scriptTag = (key, src) => {\n    if (!scriptMap.has(key)) {\n      const tag = document.createElement(\"script\");\n      const promise = new Promise((resolve, reject) => {\n        const body = document.getElementsByTagName(\"body\")[0];\n        tag.type = \"text/javascript\";\n        tag.crossorigin = \"crossorigin\";\n        tag.async = true; // Load in order\n\n        const cbName = `loaderCB${counter++}${Date.now()}`;\n\n        const cleanup = () => {\n          if (global[cbName] && typeof global[cbName] === \"function\") {\n            global[cbName] = null;\n          }\n        };\n\n        const handleResult = state => evt => {\n          const stored = scriptMap.get(key);\n          stored.resolved = false;\n          stored.resolved = false;\n          if (state === \"loaded\") {\n            stored.resolved = true;\n            resolve(src);\n            // stored.handlers.forEach(h => h.call(null, stored))\n            // stored.handlers = []\n          } else if (state === \"error\") {\n            stored.errored = true;\n            // stored.handlers.forEach(h => h.call(null, stored))\n            // stored.handlers = [];\n            reject(evt);\n          }\n          cleanup();\n        };\n\n        tag.onload = handleResult(\"loaded\");\n        tag.onerror = handleResult(\"error\");\n        tag.onreadystatechange = () => {\n          handleResult(tag.readyState);\n        };\n\n        // Pick off callback, if there is one\n        if (src.match(/callback=CALLBACK_NAME/)) {\n          src = src.replace(/(callback=)[^&]+/, `$1${cbName}`);\n        } else {\n          tag.addEventListener(\"load\", tag.onload);\n        }\n        tag.addEventListener(\"error\", tag.onerror);\n        tag.src = src;\n        body.appendChild(tag);\n        return tag;\n      });\n      const initialState = {\n        loaded: false,\n        error: false,\n        promise,\n        tag,\n      };\n      scriptMap.set(key, initialState);\n    }\n    return scriptMap.get(key);\n  };\n\n  Object.keys(scripts).forEach(key => {\n    const script = scripts[key];\n    Cache[key] = {\n      tag: Cache.scriptTag(key, script),\n      onLoad: Cache.onLoad(key),\n    };\n  });\n\n  return Cache;\n}\n\nexport default ScriptCache;\n"],"sourceRoot":""}